'''
Created on 8 Jan. 2019

@author: Edgar
'''
'''
Created on 6 May 2018

@author: Edgar
'''
import numpy as np 
import cv2 

iHeight = 400
iWidth = 600
numberOfPhos = 20
sigma = 8.712
phosSep = 14
kernelSize = 19
phoSize =  3

#open mask
xfile=open('xf.txt','r')
yfile=open('yf.txt','r')
xlines=xfile.readlines()
ylines=yfile.readlines()

maskListLen = len(xlines)
XmaskList = list()
YmaskList = list()
for i in range(0,maskListLen):
    XmaskList.append(map(int,xlines[i].split()))
    YmaskList.append(map(int,ylines[i].split()))
#the display after random mask
t = np.zeros((600,400))
t = t.astype('uint8')
t = cv2.resize(t,(600,400))


#read and scale the image
def imread (imageName,imageHeight, imageWidth, format ):
    if format == 1 :
        img = cv2.imread(imageName,1 )
    if format == 0:
        img = cv2.imread(imageName,0)
    
    scaled = cv2.resize(img,(imageWidth,imageHeight))
    return scaled
#shows the image on the display
def imshow(name, image):
    cv2.imshow(name, image) 
    cv2.waitKey( )
    cv2.destroyAllWindows()

#gnerating kernel; 
#Phosphene seperation: 3 degrees = 3 *4.4 = 13.2 px sagma is 13.2*0.66 = 8.712
#generation of gaussain keneral and the sum
def Gkernel(kernelSize, sigma):
    kernel = np.zeros((kernelSize,kernelSize))
    for i in range(0,kernelSize):
        for j in range(0,kernelSize):
            centre = (kernelSize -1 )/2
            kernel[i,j] =  kernel[i,j]=np.exp(-((i-centre)**2+(j-centre)**2)/(2*sigma**2))
    kernelSum = np.sum(kernel)
    
    return kernel, kernelSum

def iKernel(kernelSize):
    kernel = np.zeros((kernelSize,kernelSize))
    center = (kernelSize -1)/2
    kernel[center,center] = 1
    return kernel, 1 

#numberOfPhos x means there will be x * x phosphene
#get the centre location of each section of image that is blured as vision field
#and also return a list that contains the pixels for blur as L 
# return the segmented vision the the center location of each segmented vision(phosphene)
def getVision(image, numberOfPhos,  PhosSep, kernelSize):
    visionField = np.zeros((numberOfPhos, numberOfPhos, 2))
    leftTopCornerR = 199-((numberOfPhos/2)-1) * PhosSep
    leftTopCornerC = 299-((numberOfPhos/2)-1) * PhosSep
    visionField[0,0,0] = leftTopCornerR
    visionField[0,0,1] = leftTopCornerC  
    for i in range(0,numberOfPhos,):
        for j in range(0,numberOfPhos):
            visionField[i,j,0] = visionField[0,0,0] + i * PhosSep
            visionField[i,j,1] = visionField[0,0,1] + j * PhosSep #co-ordinate of the phosphenes (location) The centre of the filtered area
          
    L = list()
   
    for i in range(0,numberOfPhos):
        L.append([])
    edge = (kernelSize-1)/2
    for i in range(0, numberOfPhos):
        for j in range(0,numberOfPhos):
            #g = scale[visionField[i,j,0]-9:visionField[i,j,0]+10,visionField[i,j,1]-9:visionField[i,j,1]+10]
            g = image[visionField[i,j,0]- edge : visionField[i,j,0]+edge+1 , visionField[i,j,1]-edge : visionField[i,j,1]+edge+1]
            L[i].append(g)
    return L, visionField

#numberOfPhos x means there will be x * x phosphene
#generating the pixels that is generated by convoloving the kernel and image
def applyKernel(numberOfPhos,kernel, kernelSum,scatterVision):
    phos = np.zeros((numberOfPhos,numberOfPhos))
    for i in range(0, numberOfPhos):
        for j in range(0,numberOfPhos):
            clip = np.copy(scatterVision[i][j])
            phos[i][j] = np.sum(np.multiply(clip,kernel))/kernelSum
    phos = phos.astype('uint8')
    #print np.shape(phos)
    return phos 
#numberOfPhos x means there will be x * x phosphene
#phos is the list containg the filtered single pixels, visionfield is the centre location of the filtered section of the image
def scatterPhos(phos, visionField, numberOfPhos, phosSize):
    stimulatedVision = np.zeros((iHeight, iWidth))
    stimulatedVision = stimulatedVision.astype('uint8')
    for i in range(0, numberOfPhos):
        for j in range(0,numberOfPhos):
            stimulatedVision[visionField[i,j,0]-phosSize:visionField[i,j,0]+phosSize+1, visionField[i,j,1]-phosSize:visionField[i,j,1]+phosSize+1] = phos[i,j]
    return stimulatedVision

#Impletemneting color quantization, clluter the image
def cluster(image):
    
    floatImage = image.reshape(-1)
    #floatImage = np.reshape(image, (-1,5)) # the second number can control the quality
    floatImage = np.float32(floatImage)
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
    #number of clusters
    K = 5
    ret,label,center=cv2.kmeans(floatImage,K,None,criteria,10,cv2.KMEANS_RANDOM_CENTERS)
    center = np.uint8(center)
    res = center[label.flatten()]
    res2 = res.reshape(image.shape)
    return res2
def scale(image,imageHeight, imageWidth):
    scaled = cv2.resize(image,(imageWidth,imageHeight))
    return scaled
cap = cv2.VideoCapture(0)
kernel, KernelSum = Gkernel(kernelSize, sigma)


while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()

    # Our operations on the frame come here
    #gray = cv2.cvtColor(frame,0)
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    scaled = scale(gray,iHeight,iWidth)
    
   
    #   clustered images
    #sv = cluster(scaled)
    
    #normal phosphenes
  
    scatterVision, visionField  =  getVision(scaled, numberOfPhos, phosSep,kernelSize)
    
    phos = applyKernel(numberOfPhos,kernel,KernelSum,scatterVision)
    
    clusters = cluster(phos)
    
    
    
    
    Max = float(np.max(clusters))
    Min = float(np.min(clusters))
    if (Max - Min == 0 ):
        slop = 0 
        intersection = 200
    else:
        slop = 255/(Max-Min)
        
        intersection = (255*Min)/(Min-Max)
    
    
    for d in range(0, numberOfPhos):
        for e in range(0,numberOfPhos):
            clusters[d][e] = slop * (clusters[d][e]) + intersection
    clusters = np.int8(clusters)
    
    # to apply the random phosphene mask 
    
    k = numberOfPhos*numberOfPhos - 1 
    for i in range (0,numberOfPhos):
        for j in range(0,numberOfPhos):
            xline = np.copy(XmaskList[k])
            yline = np.copy(YmaskList[k])
            for h in range (0, xline.size):
                t[xline[h],yline[h]] =  clusters[i][j]
            k = k - 1
    
    
    
    
    '''
    for i in range(0,maskListLen):
        xline = np.copy(XmaskList[i])
        yline = np.copy(YmaskList[i])
        for j in range(0, xline.size):
            t[xline[j]][yline[j]] = phos[i]
    '''        
            
            
            
            
            
            
 
    sv = scatterPhos(phos, visionField,numberOfPhos,phoSize)
   
    '''
    #clusters + phosphenes
    #clusters = cluster(phos)
    #scatterVision, visionField  =  getVision(clusters, numberOfPhos, phosSep,kernelSize)
    #phos = applyKernel(numberOfPhos,kernel,KernelSum,scatterVision)
    
    #sv = scatterPhos(clusters, visionField,numberOfPhos,phoSize)
    '''

    

    # Display the resulting frame
    cv2.imshow('frame',t)
    

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# When everything done, release the capture
cap.release()
cv2.destroyAllWindows()



